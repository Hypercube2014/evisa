<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/evisa-applicant-api/src/main/java/com/hypercube/evisa/applicant/api/resource/StripeWebhookController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/evisa-applicant-api/src/main/java/com/hypercube/evisa/applicant/api/resource/StripeWebhookController.java" />
              <option name="originalContent" value="package com.hypercube.evisa.applicant.api.resource;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.PostMapping;&#10;import org.springframework.web.bind.annotation.RequestBody;&#10;import org.springframework.web.bind.annotation.RequestHeader;&#10;import org.springframework.web.bind.annotation.RequestMapping;&#10;import org.springframework.web.bind.annotation.RestController;&#10;&#10;import com.hypercube.evisa.common.api.domain.ApplicantPaymentDetails;&#10;import com.hypercube.evisa.common.api.service.ApplicantPaymentService;&#10;import com.hypercube.evisa.common.api.service.ApplicationHeaderService;&#10;import com.stripe.exception.SignatureVerificationException;&#10;import com.stripe.model.Event;&#10;import com.stripe.model.PaymentIntent;&#10;import com.stripe.model.checkout.Session;&#10;import com.stripe.net.Webhook;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;/**&#10; * Contrôleur pour gérer les webhooks Stripe&#10; * Résout le problème des paiements restant en &quot;Pending&quot; si l'utilisateur ferme la fenêtre&#10; *&#10; * @author Generated&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/stripe/webhook&quot;)&#10;@Slf4j&#10;public class StripeWebhookController {&#10;&#10;    @Autowired&#10;    private ApplicantPaymentService applicantPaymentService;&#10;&#10;    @Autowired&#10;    private ApplicationHeaderService applicationHeaderService;&#10;&#10;    @Value(&quot;${stripe.webhook.secret:}&quot;)&#10;    private String webhookSecret;&#10;&#10;    /**&#10;     * Endpoint webhook pour recevoir les événements Stripe&#10;     *&#10;     * @param payload Payload JSON de Stripe&#10;     * @param sigHeader Signature Stripe pour vérification&#10;     * @return ResponseEntity avec statut&#10;     */&#10;    @PostMapping&#10;    public ResponseEntity&lt;String&gt; handleStripeWebhook(&#10;            @RequestBody String payload,&#10;            @RequestHeader(&quot;Stripe-Signature&quot;) String sigHeader) {&#10;&#10;        log.info(&quot;Réception webhook Stripe&quot;);&#10;&#10;        try {&#10;            Event event;&#10;&#10;            // Vérification de la signature si le secret est configuré&#10;            if (webhookSecret != null &amp;&amp; !webhookSecret.isEmpty()) {&#10;                event = Webhook.constructEvent(payload, sigHeader, webhookSecret);&#10;            } else {&#10;                log.warn(&quot;Secret webhook non configuré - signature non vérifiée&quot;);&#10;                event = Event.GSON.fromJson(payload, Event.class);&#10;            }&#10;&#10;            log.info(&quot;Événement Stripe reçu : {}&quot;, event.getType());&#10;&#10;            // Traitement selon le type d'événement&#10;            switch (event.getType()) {&#10;                case &quot;checkout.session.completed&quot;:&#10;                    handleCheckoutSessionCompleted(event);&#10;                    break;&#10;                case &quot;payment_intent.succeeded&quot;:&#10;                    handlePaymentSucceeded(event);&#10;                    break;&#10;                case &quot;payment_intent.payment_failed&quot;:&#10;                    handlePaymentFailed(event);&#10;                    break;&#10;                default:&#10;                    log.info(&quot;Événement non géré : {}&quot;, event.getType());&#10;            }&#10;&#10;            return ResponseEntity.ok(&quot;OK&quot;);&#10;&#10;        } catch (SignatureVerificationException e) {&#10;            log.error(&quot;Signature webhook invalide&quot;, e);&#10;            return ResponseEntity.status(400).body(&quot;Invalid signature&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur traitement webhook&quot;, e);&#10;            return ResponseEntity.status(500).body(&quot;Webhook error&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Traite l'événement checkout.session.completed&#10;     * Déclenché quand une session de checkout est complétée avec succès&#10;     */&#10;    private void handleCheckoutSessionCompleted(Event event) {&#10;        try {&#10;            log.info(&quot;Début traitement checkout.session.completed&quot;);&#10;&#10;            // Méthode simplifiée pour récupérer la session Stripe&#10;            Session session = null;&#10;            String sessionId = null;&#10;&#10;            try {&#10;                // Première méthode : via le désérialiseur&#10;                session = (Session) event.getDataObjectDeserializer().getObject().orElse(null);&#10;                if (session != null) {&#10;                    log.info(&quot;Session récupérée via getDataObjectDeserializer&quot;);&#10;                }&#10;            } catch (Exception e) {&#10;                log.warn(&quot;Échec désérialisation via getDataObjectDeserializer : {}&quot;, e.getMessage());&#10;            }&#10;&#10;            // Si la première méthode échoue, essayer via le JSON raw&#10;            if (session == null) {&#10;                try {&#10;                    // Méthode alternative : parser le JSON directement&#10;                    String jsonString = event.getData().getObject().toJson();&#10;                    log.info(&quot;JSON de l'événement : {}&quot;, jsonString);&#10;&#10;                    // Utiliser Gson pour parser le JSON et extraire l'ID&#10;                    com.google.gson.JsonObject jsonObject = com.google.gson.JsonParser.parseString(jsonString).getAsJsonObject();&#10;                    sessionId = jsonObject.get(&quot;id&quot;).getAsString();&#10;                    log.info(&quot;SessionId extrait du JSON : {}&quot;, sessionId);&#10;&#10;                    // Récupérer la session via l'API Stripe&#10;                    session = Session.retrieve(sessionId);&#10;                    log.info(&quot;Session récupérée via API Stripe&quot;);&#10;                } catch (Exception e) {&#10;                    log.error(&quot;Échec récupération session via JSON parsing : {}&quot;, e.getMessage());&#10;                }&#10;            }&#10;&#10;            if (session == null) {&#10;                log.error(&quot;ERREUR CRITIQUE : Impossible de récupérer la session Stripe&quot;);&#10;                log.error(&quot;SessionId disponible : {}&quot;, sessionId);&#10;                return;&#10;            }&#10;&#10;            sessionId = session.getId();&#10;            String paymentStatus = session.getPaymentStatus();&#10;            Long amountTotal = session.getAmountTotal();&#10;&#10;            log.info(&quot;Session Stripe récupérée - ID: {}, Status: {}, Montant: {}&quot;, sessionId, paymentStatus, amountTotal);&#10;&#10;            if (&quot;paid&quot;.equals(paymentStatus)) {&#10;                log.info(&quot;Session checkout complétée avec succès : {}&quot;, sessionId);&#10;&#10;                // Récupérer le paiement associé à cette session&#10;                ApplicantPaymentDetails payment = applicantPaymentService.getFileNumberBySessionId(sessionId);&#10;&#10;                if (payment != null) {&#10;                    String fileNumber = payment.getFileNumber();&#10;                    log.info(&quot;Paiement trouvé - Référence: {}, Statut actuel: {}&quot;, fileNumber, payment.getStatus());&#10;&#10;                    try {&#10;                        // 1. Mettre à jour le statut du paiement vers &quot;PC&quot; (Payment Confirmed)&#10;                        applicantPaymentService.updatePaymentSuccess(&quot;PC&quot;, amountTotal, &quot;CARD&quot;, sessionId);&#10;                        log.info(&quot;✅ Paiement mis à jour avec succès pour session : {} - Référence : {}&quot;, sessionId, fileNumber);&#10;&#10;                        // 2. Mettre à jour le statut de l'application dans tevi_header&#10;                        applicationHeaderService.updatePaymentDetails(fileNumber);&#10;                        log.info(&quot;✅ Application header mise à jour - documentStatus: SUB, visaStatus: UP pour référence : {}&quot;, fileNumber);&#10;&#10;                        log.info(&quot; SYNCHRONISATION COMPLÈTE - Paiement et application mis à jour pour référence : {}&quot;, fileNumber);&#10;&#10;                    } catch (Exception updateException) {&#10;                        log.error(&quot;❌ Erreur lors de la mise à jour du paiement/application pour référence : {}&quot;, fileNumber, updateException);&#10;                        throw updateException; // Re-lancer l'exception pour déclencher un retry webhook si nécessaire&#10;                    }&#10;&#10;                } else {&#10;                    log.warn(&quot;❌ PROBLÈME: Aucun paiement trouvé pour la session : {}&quot;, sessionId);&#10;                    log.warn(&quot;Vérifiez que le sessionId est bien stocké lors de la création de la session Stripe&quot;);&#10;                }&#10;            } else {&#10;                log.warn(&quot;Session Stripe non payée - Status: {} pour session: {}&quot;, paymentStatus, sessionId);&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur lors du traitement de checkout.session.completed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Traite l'événement payment_intent.succeeded&#10;     * Déclenché quand un PaymentIntent réussit&#10;     */&#10;    private void handlePaymentSucceeded(Event event) {&#10;        try {&#10;            PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()&#10;                .getObject().orElse(null);&#10;&#10;            if (paymentIntent != null) {&#10;                String paymentIntentId = paymentIntent.getId();&#10;                log.info(&quot;Payment Intent réussi : {}&quot;, paymentIntentId);&#10;&#10;                // Note: Pour associer ce PaymentIntent à nos paiements, nous aurions besoin&#10;                // de stocker l'ID du PaymentIntent lors de la création de la session&#10;                // Pour l'instant, nous nous appuyons sur checkout.session.completed&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur lors du traitement de payment_intent.succeeded&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Traite l'événement payment_intent.payment_failed&#10;     * Déclenché quand un PaymentIntent échoue&#10;     */&#10;    private void handlePaymentFailed(Event event) {&#10;        try {&#10;            PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()&#10;                .getObject().orElse(null);&#10;&#10;            if (paymentIntent != null) {&#10;                String paymentIntentId = paymentIntent.getId();&#10;                log.info(&quot;Payment Intent échoué : {}&quot;, paymentIntentId);&#10;&#10;                // Note: Même commentaire que pour payment_intent.succeeded&#10;                // Nous nous appuyons principalement sur checkout.session.completed&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur lors du traitement de payment_intent.payment_failed&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hypercube.evisa.applicant.api.resource;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.PostMapping;&#10;import org.springframework.web.bind.annotation.RequestBody;&#10;import org.springframework.web.bind.annotation.RequestHeader;&#10;import org.springframework.web.bind.annotation.RequestMapping;&#10;import org.springframework.web.bind.annotation.RestController;&#10;&#10;import com.hypercube.evisa.common.api.domain.ApplicantPaymentDetails;&#10;import com.hypercube.evisa.common.api.service.ApplicantPaymentService;&#10;import com.hypercube.evisa.common.api.service.ApplicationHeaderService;&#10;import com.stripe.exception.SignatureVerificationException;&#10;import com.stripe.model.Event;&#10;import com.stripe.model.PaymentIntent;&#10;import com.stripe.model.checkout.Session;&#10;import com.stripe.net.Webhook;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;/**&#10; * Contrôleur pour gérer les webhooks Stripe&#10; * Résout le problème des paiements restant en &quot;Pending&quot; si l'utilisateur ferme la fenêtre&#10; *&#10; * @author Generated&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/stripe/webhook&quot;)&#10;@Slf4j&#10;public class StripeWebhookController {&#10;&#10;    @Autowired&#10;    private ApplicantPaymentService applicantPaymentService;&#10;&#10;    @Autowired&#10;    private ApplicationHeaderService applicationHeaderService;&#10;&#10;    @Value(&quot;${stripe.webhook.secret:}&quot;)&#10;    private String webhookSecret;&#10;&#10;    /**&#10;     * Endpoint webhook pour recevoir les événements Stripe&#10;     *&#10;     * @param payload Payload JSON de Stripe&#10;     * @param sigHeader Signature Stripe pour vérification&#10;     * @return ResponseEntity avec statut&#10;     */&#10;    @PostMapping&#10;    public ResponseEntity&lt;String&gt; handleStripeWebhook(&#10;            @RequestBody String payload,&#10;            @RequestHeader(&quot;Stripe-Signature&quot;) String sigHeader) {&#10;&#10;        log.info(&quot;Réception webhook Stripe&quot;);&#10;&#10;        try {&#10;            Event event;&#10;&#10;            // Vérification de la signature si le secret est configuré&#10;            if (webhookSecret != null &amp;&amp; !webhookSecret.isEmpty()) {&#10;                event = Webhook.constructEvent(payload, sigHeader, webhookSecret);&#10;            } else {&#10;                log.warn(&quot;Secret webhook non configuré - signature non vérifiée&quot;);&#10;                event = Event.GSON.fromJson(payload, Event.class);&#10;            }&#10;&#10;            log.info(&quot;Événement Stripe reçu : {}&quot;, event.getType());&#10;&#10;            // Traitement selon le type d'événement&#10;            switch (event.getType()) {&#10;                case &quot;checkout.session.completed&quot;:&#10;                    handleCheckoutSessionCompleted(event);&#10;                    break;&#10;                case &quot;payment_intent.succeeded&quot;:&#10;                    handlePaymentSucceeded(event);&#10;                    break;&#10;                case &quot;payment_intent.payment_failed&quot;:&#10;                    handlePaymentFailed(event);&#10;                    break;&#10;                default:&#10;                    log.info(&quot;Événement non géré : {}&quot;, event.getType());&#10;            }&#10;&#10;            return ResponseEntity.ok(&quot;OK&quot;);&#10;&#10;        } catch (SignatureVerificationException e) {&#10;            log.error(&quot;Signature webhook invalide&quot;, e);&#10;            return ResponseEntity.status(400).body(&quot;Invalid signature&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur traitement webhook&quot;, e);&#10;            return ResponseEntity.status(500).body(&quot;Webhook error&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Traite l'événement checkout.session.completed&#10;     * Déclenché quand une session de checkout est complétée avec succès&#10;     */&#10;    private void handleCheckoutSessionCompleted(Event event) {&#10;        try {&#10;            log.info(&quot;Début traitement checkout.session.completed&quot;);&#10;&#10;            // Méthode simplifiée pour récupérer la session Stripe&#10;            Session session = null;&#10;            String sessionId = null;&#10;&#10;            try {&#10;                // Première méthode : via le désérialiseur&#10;                session = (Session) event.getDataObjectDeserializer().getObject().orElse(null);&#10;                if (session != null) {&#10;                    log.info(&quot;Session récupérée via getDataObjectDeserializer&quot;);&#10;                }&#10;            } catch (Exception e) {&#10;                log.warn(&quot;Échec désérialisation via getDataObjectDeserializer : {}&quot;, e.getMessage());&#10;            }&#10;&#10;            // Si la première méthode échoue, essayer via le JSON raw&#10;            if (session == null) {&#10;                try {&#10;                    // Méthode alternative : parser le JSON directement&#10;                    String jsonString = event.getData().getObject().toJson();&#10;                    log.info(&quot;JSON de l'événement : {}&quot;, jsonString);&#10;&#10;                    // Utiliser Gson pour parser le JSON et extraire l'ID&#10;                    com.google.gson.JsonObject jsonObject = com.google.gson.JsonParser.parseString(jsonString).getAsJsonObject();&#10;                    sessionId = jsonObject.get(&quot;id&quot;).getAsString();&#10;                    log.info(&quot;SessionId extrait du JSON : {}&quot;, sessionId);&#10;&#10;                    // Récupérer la session via l'API Stripe&#10;                    session = Session.retrieve(sessionId);&#10;                    log.info(&quot;Session récupérée via API Stripe&quot;);&#10;                } catch (Exception e) {&#10;                    log.error(&quot;Échec récupération session via JSON parsing : {}&quot;, e.getMessage());&#10;                }&#10;            }&#10;&#10;            if (session == null) {&#10;                log.error(&quot;ERREUR CRITIQUE : Impossible de récupérer la session Stripe&quot;);&#10;                log.error(&quot;SessionId disponible : {}&quot;, sessionId);&#10;                return;&#10;            }&#10;&#10;            sessionId = session.getId();&#10;            String paymentStatus = session.getPaymentStatus();&#10;            Long amountTotal = session.getAmountTotal();&#10;&#10;            log.info(&quot;Session Stripe récupérée - ID: {}, Status: {}, Montant: {}&quot;, sessionId, paymentStatus, amountTotal);&#10;&#10;            if (&quot;paid&quot;.equals(paymentStatus)) {&#10;                log.info(&quot;Session checkout complétée avec succès : {}&quot;, sessionId);&#10;&#10;                // Récupérer le paiement associé à cette session&#10;                ApplicantPaymentDetails payment = applicantPaymentService.getFileNumberBySessionId(sessionId);&#10;&#10;                if (payment != null) {&#10;                    String fileNumber = payment.getFileNumber();&#10;                    log.info(&quot;Paiement trouvé - Référence: {}, Statut actuel: {}&quot;, fileNumber, payment.getStatus());&#10;&#10;                    try {&#10;                        // 1. Mettre à jour le statut du paiement vers &quot;PC&quot; (Payment Confirmed)&#10;                        applicantPaymentService.updatePaymentSuccess(&quot;PC&quot;, amountTotal, &quot;CARD&quot;, sessionId);&#10;                        log.info(&quot;✅ Paiement mis à jour avec succès pour session : {} - Référence : {}&quot;, sessionId, fileNumber);&#10;&#10;                        // 2. Mettre à jour le statut de l'application dans tevi_header&#10;                        applicationHeaderService.updatePaymentDetails(fileNumber);&#10;                        log.info(&quot;✅ Application header mise à jour - documentStatus: SUB, visaStatus: UP pour référence : {}&quot;, fileNumber);&#10;&#10;                        log.info(&quot; SYNCHRONISATION COMPLÈTE - Paiement et application mis à jour pour référence : {}&quot;, fileNumber);&#10;&#10;                    } catch (Exception updateException) {&#10;                        log.error(&quot;❌ Erreur lors de la mise à jour du paiement/application pour référence : {}&quot;, fileNumber, updateException);&#10;                        throw updateException; // Re-lancer l'exception pour déclencher un retry webhook si nécessaire&#10;                    }&#10;&#10;                } else {&#10;                    log.warn(&quot;❌ PROBLÈME: Aucun paiement trouvé pour la session : {}&quot;, sessionId);&#10;                    log.warn(&quot;Vérifiez que le sessionId est bien stocké lors de la création de la session Stripe&quot;);&#10;                }&#10;            } else {&#10;                log.warn(&quot;Session Stripe non payée - Status: {} pour session: {}&quot;, paymentStatus, sessionId);&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur lors du traitement de checkout.session.completed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Traite l'événement payment_intent.succeeded&#10;     * Déclenché quand un PaymentIntent réussit&#10;     */&#10;    private void handlePaymentSucceeded(Event event) {&#10;        try {&#10;            PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()&#10;                .getObject().orElse(null);&#10;&#10;            if (paymentIntent != null) {&#10;                String paymentIntentId = paymentIntent.getId();&#10;                log.info(&quot;Payment Intent réussi : {}&quot;, paymentIntentId);&#10;&#10;                // Note: Pour associer ce PaymentIntent à nos paiements, nous aurions besoin&#10;                // de stocker l'ID du PaymentIntent lors de la création de la session&#10;                // Pour l'instant, nous nous appuyons sur checkout.session.completed&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur lors du traitement de payment_intent.succeeded&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Traite l'événement payment_intent.payment_failed&#10;     * Déclenché quand un PaymentIntent échoue&#10;     */&#10;    private void handlePaymentFailed(Event event) {&#10;        try {&#10;            PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()&#10;                .getObject().orElse(null);&#10;&#10;            if (paymentIntent != null) {&#10;                String paymentIntentId = paymentIntent.getId();&#10;                log.info(&quot;Payment Intent échoué : {}&quot;, paymentIntentId);&#10;&#10;                // Note: Même commentaire que pour payment_intent.succeeded&#10;                // Nous nous appuyons principalement sur checkout.session.completed&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erreur lors du traitement de payment_intent.payment_failed&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/evisa-approver-ui/dist/assets/css/landing.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/evisa-approver-ui/dist/assets/css/landing.css" />
              <option name="originalContent" value="/*&#10; Medicio Bootstrap theme by BootstrapTaste.com&#10; Theme URI: http://bootstraptaste.com/medicio-free-bootstrap-theme/&#10; Author: BootstrapTaste&#10; Author URI: http://bootstraptaste.com&#10; */&#10; &#10;&#10;/* ==== Google font ==== */&#10;@import url('http://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,600,700,800|Roboto:400,500,700,900');&#10;/* --- pe-icon-7-stroke --- */&#10;&#10;&#10;" />
              <option name="updatedContent" value="/*&#10; Medicio Bootstrap theme by BootstrapTaste.com&#10; Theme URI: http://bootstraptaste.com/medicio-free-bootstrap-theme/&#10; Author: BootstrapTaste&#10; Author URI: http://bootstraptaste.com&#10; */&#10; &#10;&#10;/* ==== Google font ==== */&#10;@import url('https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,600,700,800|Roboto:400,500,700,900');&#10;/* --- pe-icon-7-stroke --- */" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>